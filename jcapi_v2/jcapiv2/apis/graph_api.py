# coding: utf-8

"""
    JumpCloud Directory API

    Allow cusotmers to manage the JumpCloud Directory objects, groupings and mappings.

    OpenAPI spec version: 2.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class GraphApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def application_associations_list(self, application_id, targets, **kwargs):
        """
        List associations of a application
        This lists the _direct_ associations of this Application. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_associations_list(application_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.application_associations_list_with_http_info(application_id, targets, **kwargs)
        else:
            (data) = self.application_associations_list_with_http_info(application_id, targets, **kwargs)
            return data

    def application_associations_list_with_http_info(self, application_id, targets, **kwargs):
        """
        List associations of a application
        This lists the _direct_ associations of this Application. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_associations_list_with_http_info(application_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params) or (params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `application_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `application_associations_list`")


        collection_formats = {}

        resource_path = '/applications/{application_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def application_associations_post(self, application_id, body, **kwargs):
        """
        Manage associations of an Application
        This manages the _direct_ associations of an Application 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_associations_post(application_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.application_associations_post_with_http_info(application_id, body, **kwargs)
        else:
            (data) = self.application_associations_post_with_http_info(application_id, body, **kwargs)
            return data

    def application_associations_post_with_http_info(self, application_id, body, **kwargs):
        """
        Manage associations of an Application
        This manages the _direct_ associations of an Application 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_associations_post_with_http_info(application_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params) or (params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `application_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `application_associations_post`")


        collection_formats = {}

        resource_path = '/applications/{application_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def application_server_traverse_user(self, application_id, **kwargs):
        """
        Get the Users an Application is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Application to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this Application to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this Application. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_server_traverse_user(application_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.application_server_traverse_user_with_http_info(application_id, **kwargs)
        else:
            (data) = self.application_server_traverse_user_with_http_info(application_id, **kwargs)
            return data

    def application_server_traverse_user_with_http_info(self, application_id, **kwargs):
        """
        Get the Users an Application is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Application to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this Application to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this Application. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_server_traverse_user_with_http_info(application_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_server_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params) or (params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `application_server_traverse_user`")


        collection_formats = {}

        resource_path = '/applications/{application_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def application_traverse_user_groups(self, application_id, **kwargs):
        """
        Get the User Groups an Application is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Application to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Application to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this Application. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_traverse_user_groups(application_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.application_traverse_user_groups_with_http_info(application_id, **kwargs)
        else:
            (data) = self.application_traverse_user_groups_with_http_info(application_id, **kwargs)
            return data

    def application_traverse_user_groups_with_http_info(self, application_id, **kwargs):
        """
        Get the User Groups an Application is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Application to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Application to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this Application. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.application_traverse_user_groups_with_http_info(application_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str application_id: ObjectID of the Application. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_traverse_user_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params) or (params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `application_traverse_user_groups`")


        collection_formats = {}

        resource_path = '/applications/{application_id}/usergroups'.replace('{format}', 'json')
        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def command_associations_list(self, command_id, targets, **kwargs):
        """
        List associations of a command
        This lists the _direct_ associations of this Command. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_associations_list(command_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.command_associations_list_with_http_info(command_id, targets, **kwargs)
        else:
            (data) = self.command_associations_list_with_http_info(command_id, targets, **kwargs)
            return data

    def command_associations_list_with_http_info(self, command_id, targets, **kwargs):
        """
        List associations of a command
        This lists the _direct_ associations of this Command. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_associations_list_with_http_info(command_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['command_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method command_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'command_id' is set
        if ('command_id' not in params) or (params['command_id'] is None):
            raise ValueError("Missing the required parameter `command_id` when calling `command_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `command_associations_list`")


        collection_formats = {}

        resource_path = '/commands/{command_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'command_id' in params:
            path_params['command_id'] = params['command_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def command_associations_post(self, command_id, body, **kwargs):
        """
        Manage associations of a Command
        This manages the _direct_ associations of a Command 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_associations_post(command_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.command_associations_post_with_http_info(command_id, body, **kwargs)
        else:
            (data) = self.command_associations_post_with_http_info(command_id, body, **kwargs)
            return data

    def command_associations_post_with_http_info(self, command_id, body, **kwargs):
        """
        Manage associations of a Command
        This manages the _direct_ associations of a Command 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_associations_post_with_http_info(command_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['command_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method command_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'command_id' is set
        if ('command_id' not in params) or (params['command_id'] is None):
            raise ValueError("Missing the required parameter `command_id` when calling `command_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `command_associations_post`")


        collection_formats = {}

        resource_path = '/commands/{command_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'command_id' in params:
            path_params['command_id'] = params['command_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def command_traverse_system(self, command_id, **kwargs):
        """
        Get the Systems an Command is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Command to any Systems it is connected to. It is arranged as a hash of System IDs for easy lookup.  It also contains a `path` array that describes each path from this Command to the corresponding System; this array reprents all grouping and/or associations that would have to be removed to deprovision that System from this Command. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_traverse_system(command_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.command_traverse_system_with_http_info(command_id, **kwargs)
        else:
            (data) = self.command_traverse_system_with_http_info(command_id, **kwargs)
            return data

    def command_traverse_system_with_http_info(self, command_id, **kwargs):
        """
        Get the Systems an Command is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Command to any Systems it is connected to. It is arranged as a hash of System IDs for easy lookup.  It also contains a `path` array that describes each path from this Command to the corresponding System; this array reprents all grouping and/or associations that would have to be removed to deprovision that System from this Command. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_traverse_system_with_http_info(command_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['command_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method command_traverse_system" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'command_id' is set
        if ('command_id' not in params) or (params['command_id'] is None):
            raise ValueError("Missing the required parameter `command_id` when calling `command_traverse_system`")


        collection_formats = {}

        resource_path = '/commands/{command_id}/systems'.replace('{format}', 'json')
        path_params = {}
        if 'command_id' in params:
            path_params['command_id'] = params['command_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def command_traverse_system_group(self, command_id, **kwargs):
        """
        Get the System Groups an Command is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Command to any System Groups it is connected to. It is arranged as a hash of System Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Command to the corresponding System Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that System Group from this Command. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_traverse_system_group(command_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.command_traverse_system_group_with_http_info(command_id, **kwargs)
        else:
            (data) = self.command_traverse_system_group_with_http_info(command_id, **kwargs)
            return data

    def command_traverse_system_group_with_http_info(self, command_id, **kwargs):
        """
        Get the System Groups an Command is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Command to any System Groups it is connected to. It is arranged as a hash of System Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Command to the corresponding System Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that System Group from this Command. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.command_traverse_system_group_with_http_info(command_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str command_id: ObjectID of the Command. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['command_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method command_traverse_system_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'command_id' is set
        if ('command_id' not in params) or (params['command_id'] is None):
            raise ValueError("Missing the required parameter `command_id` when calling `command_traverse_system_group`")


        collection_formats = {}

        resource_path = '/commands/{command_id}/systemgroups'.replace('{format}', 'json')
        path_params = {}
        if 'command_id' in params:
            path_params['command_id'] = params['command_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def g_suite_associations_list(self, gsuite_id, targets, **kwargs):
        """
        List associations of a G Suite instance.
        This lists the _direct_ associations of this G Suite instance. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_associations_list(gsuite_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.g_suite_associations_list_with_http_info(gsuite_id, targets, **kwargs)
        else:
            (data) = self.g_suite_associations_list_with_http_info(gsuite_id, targets, **kwargs)
            return data

    def g_suite_associations_list_with_http_info(self, gsuite_id, targets, **kwargs):
        """
        List associations of a G Suite instance.
        This lists the _direct_ associations of this G Suite instance. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_associations_list_with_http_info(gsuite_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gsuite_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_suite_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gsuite_id' is set
        if ('gsuite_id' not in params) or (params['gsuite_id'] is None):
            raise ValueError("Missing the required parameter `gsuite_id` when calling `g_suite_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `g_suite_associations_list`")


        collection_formats = {}

        resource_path = '/gsuites/{gsuite_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'gsuite_id' in params:
            path_params['gsuite_id'] = params['gsuite_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def g_suite_associations_post(self, gsuite_id, body, **kwargs):
        """
        Manage associations of a G Suite instance.
        This manages the _direct_ associations of a G Suite instance. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_associations_post(gsuite_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.g_suite_associations_post_with_http_info(gsuite_id, body, **kwargs)
        else:
            (data) = self.g_suite_associations_post_with_http_info(gsuite_id, body, **kwargs)
            return data

    def g_suite_associations_post_with_http_info(self, gsuite_id, body, **kwargs):
        """
        Manage associations of a G Suite instance.
        This manages the _direct_ associations of a G Suite instance. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_associations_post_with_http_info(gsuite_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gsuite_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_suite_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gsuite_id' is set
        if ('gsuite_id' not in params) or (params['gsuite_id'] is None):
            raise ValueError("Missing the required parameter `gsuite_id` when calling `g_suite_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `g_suite_associations_post`")


        collection_formats = {}

        resource_path = '/gsuites/{gsuite_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'gsuite_id' in params:
            path_params['gsuite_id'] = params['gsuite_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def g_suite_traverse_user(self, gsuite_id, **kwargs):
        """
        Get the Users a G Suite instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this G Suite instance to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this G Suite instance to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this G Suite instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_traverse_user(gsuite_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.g_suite_traverse_user_with_http_info(gsuite_id, **kwargs)
        else:
            (data) = self.g_suite_traverse_user_with_http_info(gsuite_id, **kwargs)
            return data

    def g_suite_traverse_user_with_http_info(self, gsuite_id, **kwargs):
        """
        Get the Users a G Suite instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this G Suite instance to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this G Suite instance to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this G Suite instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_traverse_user_with_http_info(gsuite_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gsuite_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_suite_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gsuite_id' is set
        if ('gsuite_id' not in params) or (params['gsuite_id'] is None):
            raise ValueError("Missing the required parameter `gsuite_id` when calling `g_suite_traverse_user`")


        collection_formats = {}

        resource_path = '/gsuites/{gsuite_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'gsuite_id' in params:
            path_params['gsuite_id'] = params['gsuite_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def g_suite_traverse_user_group(self, gsuite_id, **kwargs):
        """
        Get the User Groups a G Suite instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this G Suite instance to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this G Suite instance to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this G Suite instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_traverse_user_group(gsuite_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.g_suite_traverse_user_group_with_http_info(gsuite_id, **kwargs)
        else:
            (data) = self.g_suite_traverse_user_group_with_http_info(gsuite_id, **kwargs)
            return data

    def g_suite_traverse_user_group_with_http_info(self, gsuite_id, **kwargs):
        """
        Get the User Groups a G Suite instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this G Suite instance to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this G Suite instance to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this G Suite instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.g_suite_traverse_user_group_with_http_info(gsuite_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str gsuite_id: ObjectID of the G Suite instance. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gsuite_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_suite_traverse_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gsuite_id' is set
        if ('gsuite_id' not in params) or (params['gsuite_id'] is None):
            raise ValueError("Missing the required parameter `gsuite_id` when calling `g_suite_traverse_user_group`")


        collection_formats = {}

        resource_path = '/gsuites/{gsuite_id}/usergroups'.replace('{format}', 'json')
        path_params = {}
        if 'gsuite_id' in params:
            path_params['gsuite_id'] = params['gsuite_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_server_associations_list(self, ldapserver_id, targets, **kwargs):
        """
        List associations of a LDAP Server
        This lists the _direct_ associations of this LDAP Server. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_associations_list(ldapserver_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_server_associations_list_with_http_info(ldapserver_id, targets, **kwargs)
        else:
            (data) = self.ldap_server_associations_list_with_http_info(ldapserver_id, targets, **kwargs)
            return data

    def ldap_server_associations_list_with_http_info(self, ldapserver_id, targets, **kwargs):
        """
        List associations of a LDAP Server
        This lists the _direct_ associations of this LDAP Server. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_associations_list_with_http_info(ldapserver_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapserver_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_server_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ldapserver_id' is set
        if ('ldapserver_id' not in params) or (params['ldapserver_id'] is None):
            raise ValueError("Missing the required parameter `ldapserver_id` when calling `ldap_server_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `ldap_server_associations_list`")


        collection_formats = {}

        resource_path = '/ldapservers/{ldapserver_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'ldapserver_id' in params:
            path_params['ldapserver_id'] = params['ldapserver_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_server_associations_post(self, ldapserver_id, body, **kwargs):
        """
        Manage associations of a LDAP Server
        This manages the _direct_ associations of a LDAP Server 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_associations_post(ldapserver_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_server_associations_post_with_http_info(ldapserver_id, body, **kwargs)
        else:
            (data) = self.ldap_server_associations_post_with_http_info(ldapserver_id, body, **kwargs)
            return data

    def ldap_server_associations_post_with_http_info(self, ldapserver_id, body, **kwargs):
        """
        Manage associations of a LDAP Server
        This manages the _direct_ associations of a LDAP Server 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_associations_post_with_http_info(ldapserver_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapserver_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_server_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ldapserver_id' is set
        if ('ldapserver_id' not in params) or (params['ldapserver_id'] is None):
            raise ValueError("Missing the required parameter `ldapserver_id` when calling `ldap_server_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ldap_server_associations_post`")


        collection_formats = {}

        resource_path = '/ldapservers/{ldapserver_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'ldapserver_id' in params:
            path_params['ldapserver_id'] = params['ldapserver_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_server_traverse_user(self, ldapserver_id, **kwargs):
        """
        Get the Users a LDAP Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this LDAP Server to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this LDAP Server to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this LDAP Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_traverse_user(ldapserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_server_traverse_user_with_http_info(ldapserver_id, **kwargs)
        else:
            (data) = self.ldap_server_traverse_user_with_http_info(ldapserver_id, **kwargs)
            return data

    def ldap_server_traverse_user_with_http_info(self, ldapserver_id, **kwargs):
        """
        Get the Users a LDAP Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this LDAP Server to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this LDAP Server to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this LDAP Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_traverse_user_with_http_info(ldapserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapserver_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_server_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ldapserver_id' is set
        if ('ldapserver_id' not in params) or (params['ldapserver_id'] is None):
            raise ValueError("Missing the required parameter `ldapserver_id` when calling `ldap_server_traverse_user`")


        collection_formats = {}

        resource_path = '/ldapservers/{ldapserver_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'ldapserver_id' in params:
            path_params['ldapserver_id'] = params['ldapserver_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ldap_server_traverse_user_group(self, ldapserver_id, **kwargs):
        """
        Get the User Groups a LDAP Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this LDAP Server to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this LDAP Server to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this LDAP Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_traverse_user_group(ldapserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ldap_server_traverse_user_group_with_http_info(ldapserver_id, **kwargs)
        else:
            (data) = self.ldap_server_traverse_user_group_with_http_info(ldapserver_id, **kwargs)
            return data

    def ldap_server_traverse_user_group_with_http_info(self, ldapserver_id, **kwargs):
        """
        Get the User Groups a LDAP Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this LDAP Server to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this LDAP Server to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this LDAP Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ldap_server_traverse_user_group_with_http_info(ldapserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str ldapserver_id: ObjectID of the LDAP Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapserver_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_server_traverse_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ldapserver_id' is set
        if ('ldapserver_id' not in params) or (params['ldapserver_id'] is None):
            raise ValueError("Missing the required parameter `ldapserver_id` when calling `ldap_server_traverse_user_group`")


        collection_formats = {}

        resource_path = '/ldapservers/{ldapserver_id}/usergroups'.replace('{format}', 'json')
        path_params = {}
        if 'ldapserver_id' in params:
            path_params['ldapserver_id'] = params['ldapserver_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def office365_associations_list(self, office365_id, targets, **kwargs):
        """
        List associations of a Office 365 instance.
        This lists the _direct_ associations of this Office 365 instance. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_associations_list(office365_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 instance. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.office365_associations_list_with_http_info(office365_id, targets, **kwargs)
        else:
            (data) = self.office365_associations_list_with_http_info(office365_id, targets, **kwargs)
            return data

    def office365_associations_list_with_http_info(self, office365_id, targets, **kwargs):
        """
        List associations of a Office 365 instance.
        This lists the _direct_ associations of this Office 365 instance. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_associations_list_with_http_info(office365_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 instance. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office365_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office365_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office365_id' is set
        if ('office365_id' not in params) or (params['office365_id'] is None):
            raise ValueError("Missing the required parameter `office365_id` when calling `office365_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `office365_associations_list`")


        collection_formats = {}

        resource_path = '/office365s/{office365_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'office365_id' in params:
            path_params['office365_id'] = params['office365_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def office365_associations_post(self, office365_id, body, **kwargs):
        """
        Manage associations of a Office 365 suite.
        This manages the _direct_ associations of a Office 365 suite. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_associations_post(office365_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 instance. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.office365_associations_post_with_http_info(office365_id, body, **kwargs)
        else:
            (data) = self.office365_associations_post_with_http_info(office365_id, body, **kwargs)
            return data

    def office365_associations_post_with_http_info(self, office365_id, body, **kwargs):
        """
        Manage associations of a Office 365 suite.
        This manages the _direct_ associations of a Office 365 suite. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_associations_post_with_http_info(office365_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 instance. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office365_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office365_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office365_id' is set
        if ('office365_id' not in params) or (params['office365_id'] is None):
            raise ValueError("Missing the required parameter `office365_id` when calling `office365_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `office365_associations_post`")


        collection_formats = {}

        resource_path = '/office365s/{office365_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'office365_id' in params:
            path_params['office365_id'] = params['office365_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def office365_traverse_user(self, office365_id, **kwargs):
        """
        Get the Users a Office 365 instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Office 365 instance to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this Office 365 instance to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this Office 365 instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_traverse_user(office365_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 suite. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.office365_traverse_user_with_http_info(office365_id, **kwargs)
        else:
            (data) = self.office365_traverse_user_with_http_info(office365_id, **kwargs)
            return data

    def office365_traverse_user_with_http_info(self, office365_id, **kwargs):
        """
        Get the Users a Office 365 instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Office 365 instance to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this Office 365 instance to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this Office 365 instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_traverse_user_with_http_info(office365_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 suite. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office365_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office365_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office365_id' is set
        if ('office365_id' not in params) or (params['office365_id'] is None):
            raise ValueError("Missing the required parameter `office365_id` when calling `office365_traverse_user`")


        collection_formats = {}

        resource_path = '/office365s/{office365_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'office365_id' in params:
            path_params['office365_id'] = params['office365_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def office365_traverse_user_group(self, office365_id, **kwargs):
        """
        Get the User Groups a Office 365 instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Office 365 instance to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Office 365 instance to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this Office 365 instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_traverse_user_group(office365_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 suite. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.office365_traverse_user_group_with_http_info(office365_id, **kwargs)
        else:
            (data) = self.office365_traverse_user_group_with_http_info(office365_id, **kwargs)
            return data

    def office365_traverse_user_group_with_http_info(self, office365_id, **kwargs):
        """
        Get the User Groups a Office 365 instance is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Office 365 instance to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Office 365 instance to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this Office 365 instance. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.office365_traverse_user_group_with_http_info(office365_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str office365_id: ObjectID of the Office 365 suite. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['office365_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method office365_traverse_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'office365_id' is set
        if ('office365_id' not in params) or (params['office365_id'] is None):
            raise ValueError("Missing the required parameter `office365_id` when calling `office365_traverse_user_group`")


        collection_formats = {}

        resource_path = '/office365s/{office365_id}/usergroups'.replace('{format}', 'json')
        path_params = {}
        if 'office365_id' in params:
            path_params['office365_id'] = params['office365_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def radius_server_associations_list(self, radiusserver_id, targets, **kwargs):
        """
        List associations of a Radius Server
        This lists the _direct_ associations of this Radius Server. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_associations_list(radiusserver_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.radius_server_associations_list_with_http_info(radiusserver_id, targets, **kwargs)
        else:
            (data) = self.radius_server_associations_list_with_http_info(radiusserver_id, targets, **kwargs)
            return data

    def radius_server_associations_list_with_http_info(self, radiusserver_id, targets, **kwargs):
        """
        List associations of a Radius Server
        This lists the _direct_ associations of this Radius Server. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_associations_list_with_http_info(radiusserver_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['radiusserver_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radius_server_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'radiusserver_id' is set
        if ('radiusserver_id' not in params) or (params['radiusserver_id'] is None):
            raise ValueError("Missing the required parameter `radiusserver_id` when calling `radius_server_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `radius_server_associations_list`")


        collection_formats = {}

        resource_path = '/radiusservers/{radiusserver_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'radiusserver_id' in params:
            path_params['radiusserver_id'] = params['radiusserver_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def radius_server_associations_post(self, radiusserver_id, body, **kwargs):
        """
        Manage associations of a Radius Server
        This manages the _direct_ associations of a Radius Server 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_associations_post(radiusserver_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.radius_server_associations_post_with_http_info(radiusserver_id, body, **kwargs)
        else:
            (data) = self.radius_server_associations_post_with_http_info(radiusserver_id, body, **kwargs)
            return data

    def radius_server_associations_post_with_http_info(self, radiusserver_id, body, **kwargs):
        """
        Manage associations of a Radius Server
        This manages the _direct_ associations of a Radius Server 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_associations_post_with_http_info(radiusserver_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['radiusserver_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radius_server_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'radiusserver_id' is set
        if ('radiusserver_id' not in params) or (params['radiusserver_id'] is None):
            raise ValueError("Missing the required parameter `radiusserver_id` when calling `radius_server_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `radius_server_associations_post`")


        collection_formats = {}

        resource_path = '/radiusservers/{radiusserver_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'radiusserver_id' in params:
            path_params['radiusserver_id'] = params['radiusserver_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def radius_server_traverse_user(self, radiusserver_id, **kwargs):
        """
        Get the Users a Radius Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Radius Server to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this Radius Server to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this Radius Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_traverse_user(radiusserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.radius_server_traverse_user_with_http_info(radiusserver_id, **kwargs)
        else:
            (data) = self.radius_server_traverse_user_with_http_info(radiusserver_id, **kwargs)
            return data

    def radius_server_traverse_user_with_http_info(self, radiusserver_id, **kwargs):
        """
        Get the Users a Radius Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Radius Server to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this Radius Server to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this Radius Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_traverse_user_with_http_info(radiusserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['radiusserver_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radius_server_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'radiusserver_id' is set
        if ('radiusserver_id' not in params) or (params['radiusserver_id'] is None):
            raise ValueError("Missing the required parameter `radiusserver_id` when calling `radius_server_traverse_user`")


        collection_formats = {}

        resource_path = '/radiusservers/{radiusserver_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'radiusserver_id' in params:
            path_params['radiusserver_id'] = params['radiusserver_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def radius_server_traverse_user_group(self, radiusserver_id, **kwargs):
        """
        Get the User Groups a Radius Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Radius Server to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Radius Server to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this Radius Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_traverse_user_group(radiusserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.radius_server_traverse_user_group_with_http_info(radiusserver_id, **kwargs)
        else:
            (data) = self.radius_server_traverse_user_group_with_http_info(radiusserver_id, **kwargs)
            return data

    def radius_server_traverse_user_group_with_http_info(self, radiusserver_id, **kwargs):
        """
        Get the User Groups a Radius Server is associated with.
        **read-only**  This endpoint follows the grouping and associations from this Radius Server to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this Radius Server to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this Radius Server. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.radius_server_traverse_user_group_with_http_info(radiusserver_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str radiusserver_id: ObjectID of the Radius Server. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['radiusserver_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radius_server_traverse_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'radiusserver_id' is set
        if ('radiusserver_id' not in params) or (params['radiusserver_id'] is None):
            raise ValueError("Missing the required parameter `radiusserver_id` when calling `radius_server_traverse_user_group`")


        collection_formats = {}

        resource_path = '/radiusservers/{radiusserver_id}/usergroups'.replace('{format}', 'json')
        path_params = {}
        if 'radiusserver_id' in params:
            path_params['radiusserver_id'] = params['radiusserver_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_associations_list(self, system_id, targets, **kwargs):
        """
        List associations of a System
        This lists the _direct_ associations of this System. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_associations_list(system_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_associations_list_with_http_info(system_id, targets, **kwargs)
        else:
            (data) = self.system_associations_list_with_http_info(system_id, targets, **kwargs)
            return data

    def system_associations_list_with_http_info(self, system_id, targets, **kwargs):
        """
        List associations of a System
        This lists the _direct_ associations of this System. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_associations_list_with_http_info(system_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_id' is set
        if ('system_id' not in params) or (params['system_id'] is None):
            raise ValueError("Missing the required parameter `system_id` when calling `system_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `system_associations_list`")


        collection_formats = {}

        resource_path = '/systems/{system_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'system_id' in params:
            path_params['system_id'] = params['system_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_associations_post(self, system_id, body, **kwargs):
        """
        Manage associations of a System
        This manages the _direct_ associations (non-Systems and System Groups) of a system. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_associations_post(system_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_associations_post_with_http_info(system_id, body, **kwargs)
        else:
            (data) = self.system_associations_post_with_http_info(system_id, body, **kwargs)
            return data

    def system_associations_post_with_http_info(self, system_id, body, **kwargs):
        """
        Manage associations of a System
        This manages the _direct_ associations (non-Systems and System Groups) of a system. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_associations_post_with_http_info(system_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_id' is set
        if ('system_id' not in params) or (params['system_id'] is None):
            raise ValueError("Missing the required parameter `system_id` when calling `system_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_associations_post`")


        collection_formats = {}

        resource_path = '/systems/{system_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'system_id' in params:
            path_params['system_id'] = params['system_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_associations_list(self, group_id, targets, **kwargs):
        """
        List associations of a System Group.
        This lists the _direct_ associations of this System Group. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_associations_list(group_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_associations_list_with_http_info(group_id, targets, **kwargs)
        else:
            (data) = self.system_group_associations_list_with_http_info(group_id, targets, **kwargs)
            return data

    def system_group_associations_list_with_http_info(self, group_id, targets, **kwargs):
        """
        List associations of a System Group.
        This lists the _direct_ associations of this System Group. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_associations_list_with_http_info(group_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `system_group_associations_list`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_associations_post(self, group_id, body, **kwargs):
        """
        Manage associations of a System Group
        This manages the _direct_ associations (non-Systems and System Groups) of a group. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_associations_post(group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_associations_post_with_http_info(group_id, body, **kwargs)
        else:
            (data) = self.system_group_associations_post_with_http_info(group_id, body, **kwargs)
            return data

    def system_group_associations_post_with_http_info(self, group_id, body, **kwargs):
        """
        Manage associations of a System Group
        This manages the _direct_ associations (non-Systems and System Groups) of a group. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_associations_post_with_http_info(group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_group_associations_post`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_member_of(self, group_id, **kwargs):
        """
        Get System Group's groups it is a member of.
        This lists all groups a system group is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_member_of(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_member_of_with_http_info(group_id, **kwargs)
        else:
            (data) = self.system_group_member_of_with_http_info(group_id, **kwargs)
            return data

    def system_group_member_of_with_http_info(self, group_id, **kwargs):
        """
        Get System Group's groups it is a member of.
        This lists all groups a system group is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_member_of_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_member_of" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_member_of`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/memberof'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_members_list(self, group_id, **kwargs):
        """
        List members of a System Group
        This lists the _direct_ children (Systems and System Groups) of this group. That is to say it does not recurse through children groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_members_list(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_members_list_with_http_info(group_id, **kwargs)
        else:
            (data) = self.system_group_members_list_with_http_info(group_id, **kwargs)
            return data

    def system_group_members_list_with_http_info(self, group_id, **kwargs):
        """
        List members of a System Group
        This lists the _direct_ children (Systems and System Groups) of this group. That is to say it does not recurse through children groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_members_list_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_members_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_members_list`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/members'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_membership(self, group_id, **kwargs):
        """
        Get System and System Group's who are members of this group.
        This lists all the systems and system groups that are a member of this system group. That is to say it includes nested group members of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_membership(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_membership_with_http_info(group_id, **kwargs)
        else:
            (data) = self.system_group_membership_with_http_info(group_id, **kwargs)
            return data

    def system_group_membership_with_http_info(self, group_id, **kwargs):
        """
        Get System and System Group's who are members of this group.
        This lists all the systems and system groups that are a member of this system group. That is to say it includes nested group members of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_membership_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_membership`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/membership'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_traverse_user(self, group_id, **kwargs):
        """
        Get the Users a System Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this System Group to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this System Group to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this System Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_traverse_user(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_traverse_user_with_http_info(group_id, **kwargs)
        else:
            (data) = self.system_group_traverse_user_with_http_info(group_id, **kwargs)
            return data

    def system_group_traverse_user_with_http_info(self, group_id, **kwargs):
        """
        Get the Users a System Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this System Group to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this System Group to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this System Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_traverse_user_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_traverse_user`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_group_traverse_user_group(self, group_id, **kwargs):
        """
        Get the User Groups a System Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this System Group to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this System Group to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this System Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_traverse_user_group(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_group_traverse_user_group_with_http_info(group_id, **kwargs)
        else:
            (data) = self.system_group_traverse_user_group_with_http_info(group_id, **kwargs)
            return data

    def system_group_traverse_user_group_with_http_info(self, group_id, **kwargs):
        """
        Get the User Groups a System Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this System Group to any User Groups it is connected to. It is arranged as a hash of User Group IDs for easy lookup.  It also contains a `path` array that describes each path from this System Group to the corresponding User Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that User Group from this System Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_group_traverse_user_group_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the System Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_group_traverse_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `system_group_traverse_user_group`")


        collection_formats = {}

        resource_path = '/systemgroups/{group_id}/usergroups'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_member_of(self, system_id, **kwargs):
        """
        Get System's groups it is a member of.
        This lists all groups a system is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_member_of(system_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_member_of_with_http_info(system_id, **kwargs)
        else:
            (data) = self.system_member_of_with_http_info(system_id, **kwargs)
            return data

    def system_member_of_with_http_info(self, system_id, **kwargs):
        """
        Get System's groups it is a member of.
        This lists all groups a system is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_member_of_with_http_info(system_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_member_of" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_id' is set
        if ('system_id' not in params) or (params['system_id'] is None):
            raise ValueError("Missing the required parameter `system_id` when calling `system_member_of`")


        collection_formats = {}

        resource_path = '/systems/{system_id}/memberof'.replace('{format}', 'json')
        path_params = {}
        if 'system_id' in params:
            path_params['system_id'] = params['system_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def system_traverse_user(self, system_id, **kwargs):
        """
        Get the Users a System is associated with.
        **read-only**  This endpoint follows the grouping and associations from this System to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this System to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this System. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_traverse_user(system_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.system_traverse_user_with_http_info(system_id, **kwargs)
        else:
            (data) = self.system_traverse_user_with_http_info(system_id, **kwargs)
            return data

    def system_traverse_user_with_http_info(self, system_id, **kwargs):
        """
        Get the Users a System is associated with.
        **read-only**  This endpoint follows the grouping and associations from this System to any Users it is connected to. It is arranged as a hash of User IDs for easy lookup.  It also contains a `path` array that describes each path from this System to the corresponding User; this array reprents all grouping and/or associations that would have to be removed to deprovision that User from this System. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.system_traverse_user_with_http_info(system_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str system_id: ObjectID of the System. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_traverse_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_id' is set
        if ('system_id' not in params) or (params['system_id'] is None):
            raise ValueError("Missing the required parameter `system_id` when calling `system_traverse_user`")


        collection_formats = {}

        resource_path = '/systems/{system_id}/users'.replace('{format}', 'json')
        path_params = {}
        if 'system_id' in params:
            path_params['system_id'] = params['system_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_associations_list(self, user_id, targets, **kwargs):
        """
        List associations of a User.
        This lists the _direct_ associations of this User. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_associations_list(user_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_associations_list_with_http_info(user_id, targets, **kwargs)
        else:
            (data) = self.user_associations_list_with_http_info(user_id, targets, **kwargs)
            return data

    def user_associations_list_with_http_info(self, user_id, targets, **kwargs):
        """
        List associations of a User.
        This lists the _direct_ associations of this User. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_associations_list_with_http_info(user_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `user_associations_list`")


        collection_formats = {}

        resource_path = '/users/{user_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_associations_post(self, user_id, body, **kwargs):
        """
        Manage associations of a User
        This manages the _direct_ associations (non-Users and User Groups) of a user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_associations_post(user_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_associations_post_with_http_info(user_id, body, **kwargs)
        else:
            (data) = self.user_associations_post_with_http_info(user_id, body, **kwargs)
            return data

    def user_associations_post_with_http_info(self, user_id, body, **kwargs):
        """
        Manage associations of a User
        This manages the _direct_ associations (non-Users and User Groups) of a user. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_associations_post_with_http_info(user_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `user_associations_post`")


        collection_formats = {}

        resource_path = '/users/{user_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_associations_list(self, group_id, targets, **kwargs):
        """
        List associations of a User Group.
        This lists the _direct_ associations of this User Group. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_associations_list(group_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_associations_list_with_http_info(group_id, targets, **kwargs)
        else:
            (data) = self.user_group_associations_list_with_http_info(group_id, targets, **kwargs)
            return data

    def user_group_associations_list_with_http_info(self, group_id, targets, **kwargs):
        """
        List associations of a User Group.
        This lists the _direct_ associations of this User Group. That is to say it does not traverse through Groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_associations_list_with_http_info(group_id, targets, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param list[str] targets:  (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'targets', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_associations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_associations_list`")
        # verify the required parameter 'targets' is set
        if ('targets' not in params) or (params['targets'] is None):
            raise ValueError("Missing the required parameter `targets` when calling `user_group_associations_list`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']
        if 'targets' in params:
            query_params['targets'] = params['targets']
            collection_formats['targets'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_associations_post(self, group_id, body, **kwargs):
        """
        Manage associations of a User Group
        This manages the _direct_ associations (non-Users and User Groups) of a group. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_associations_post(group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_associations_post_with_http_info(group_id, body, **kwargs)
        else:
            (data) = self.user_group_associations_post_with_http_info(group_id, body, **kwargs)
            return data

    def user_group_associations_post_with_http_info(self, group_id, body, **kwargs):
        """
        Manage associations of a User Group
        This manages the _direct_ associations (non-Users and User Groups) of a group. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_associations_post_with_http_info(group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_associations_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_associations_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `user_group_associations_post`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/associations'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_member_of(self, group_id, **kwargs):
        """
        Get User Group's groups it is a member of.
        This lists all groups a User Group is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_member_of(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_member_of_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_member_of_with_http_info(group_id, **kwargs)
            return data

    def user_group_member_of_with_http_info(self, group_id, **kwargs):
        """
        Get User Group's groups it is a member of.
        This lists all groups a User Group is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_member_of_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_member_of" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_member_of`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/memberof'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_members_list(self, group_id, **kwargs):
        """
        List members of a User Group
        This lists the _direct_ children (Users and User Groups) of this group. That is to say it does not recurse through children groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_members_list(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_members_list_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_members_list_with_http_info(group_id, **kwargs)
            return data

    def user_group_members_list_with_http_info(self, group_id, **kwargs):
        """
        List members of a User Group
        This lists the _direct_ children (Users and User Groups) of this group. That is to say it does not recurse through children groups.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_members_list_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphConnection]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_members_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_members_list`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/members'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphConnection]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_members_post(self, group_id, body, **kwargs):
        """
        Manage members of a User Group
        This manages the _direct_ children (Users and User Groups) of a group.  A User Group can contain Users and User Groups. No cycles are allowed; i.e.  if Group A contains Group B then Group B cannot also contain Group A, including any deeper nested relationships. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_members_post(group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_members_post_with_http_info(group_id, body, **kwargs)
        else:
            (data) = self.user_group_members_post_with_http_info(group_id, body, **kwargs)
            return data

    def user_group_members_post_with_http_info(self, group_id, body, **kwargs):
        """
        Manage members of a User Group
        This manages the _direct_ children (Users and User Groups) of a group.  A User Group can contain Users and User Groups. No cycles are allowed; i.e.  if Group A contains Group B then Group B cannot also contain Group A, including any deeper nested relationships. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_members_post_with_http_info(group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param GraphManagementReq body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_members_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_members_post`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `user_group_members_post`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/members'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_membership(self, group_id, **kwargs):
        """
        Get User and User Group's who are members of this group.
        This lists all the users and user groups that are a member of this user group. That is to say it includes nested group members of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_membership(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_membership_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_membership_with_http_info(group_id, **kwargs)
            return data

    def user_group_membership_with_http_info(self, group_id, **kwargs):
        """
        Get User and User Group's who are members of this group.
        This lists all the users and user groups that are a member of this user group. That is to say it includes nested group members of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_membership_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_membership`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/membership'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_application(self, group_id, **kwargs):
        """
        Get the Applications a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Applications it is connected to. It is arranged as a hash of Application IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Application; this array reprents all grouping and/or associations that would have to be removed to deprovision that Application from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_application(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_application_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_application_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_application_with_http_info(self, group_id, **kwargs):
        """
        Get the Applications a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Applications it is connected to. It is arranged as a hash of Application IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Application; this array reprents all grouping and/or associations that would have to be removed to deprovision that Application from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_application_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_application`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/applications'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_directory(self, group_id, **kwargs):
        """
        Get the Directories a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Directory (G Suite, LDAP or Office 365) it is connected to. It is arranged as a hash of Directory IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Directory; this array reprents all grouping and/or associations that would have to be removed to deprovision that Directory instance from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_directory(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_directory_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_directory_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_directory_with_http_info(self, group_id, **kwargs):
        """
        Get the Directories a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Directory (G Suite, LDAP or Office 365) it is connected to. It is arranged as a hash of Directory IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Directory; this array reprents all grouping and/or associations that would have to be removed to deprovision that Directory instance from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_directory_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_directory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_directory`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/directories'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_g_suite(self, group_id, **kwargs):
        """
        Get the G Suite instance a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any G Suite instance it is connected to. It is arranged as a hash of G Suite instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding G Suite instance this array reprents all grouping and/or associations that would have to be removed to deprovision that G Suite instancefrom this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_g_suite(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_g_suite_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_g_suite_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_g_suite_with_http_info(self, group_id, **kwargs):
        """
        Get the G Suite instance a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any G Suite instance it is connected to. It is arranged as a hash of G Suite instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding G Suite instance this array reprents all grouping and/or associations that would have to be removed to deprovision that G Suite instancefrom this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_g_suite_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_g_suite" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_g_suite`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/gsuites'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_ldap_server(self, group_id, **kwargs):
        """
        Get the LDAP Servers a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any LDAP Servers it is connected to. It is arranged as a hash of LDAP Server IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding LDAP Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that LDAP Server from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_ldap_server(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_ldap_server_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_ldap_server_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_ldap_server_with_http_info(self, group_id, **kwargs):
        """
        Get the LDAP Servers a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any LDAP Servers it is connected to. It is arranged as a hash of LDAP Server IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding LDAP Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that LDAP Server from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_ldap_server_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_ldap_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_ldap_server`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/ldapservers'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_office365(self, group_id, **kwargs):
        """
        Get the Office 365 instance a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Office 365 instance it is connected to. It is arranged as a hash of Office 365 instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Office 365 instance this array reprents all grouping and/or associations that would have to be removed to deprovision that Office 365 instancefrom this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_office365(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_office365_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_office365_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_office365_with_http_info(self, group_id, **kwargs):
        """
        Get the Office 365 instance a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Office 365 instance it is connected to. It is arranged as a hash of Office 365 instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Office 365 instance this array reprents all grouping and/or associations that would have to be removed to deprovision that Office 365 instancefrom this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_office365_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_office365" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_office365`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/office365s'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_radius_server(self, group_id, **kwargs):
        """
        Get the Radius Servers a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Radius Servers it is connected to. It is arranged as a hash of Radius Server IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Radius Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that Radius Server from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_radius_server(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_radius_server_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_radius_server_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_radius_server_with_http_info(self, group_id, **kwargs):
        """
        Get the Radius Servers a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Radius Servers it is connected to. It is arranged as a hash of Radius Server IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding Radius Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that Radius Server from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_radius_server_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_radius_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_radius_server`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/radiusservers'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_system(self, group_id, **kwargs):
        """
        Get the Systems a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Systems it is connected to. It is arranged as a hash of System IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding System; this array reprents all grouping and/or associations that would have to be removed to deprovision that System from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_system(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_system_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_system_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_system_with_http_info(self, group_id, **kwargs):
        """
        Get the Systems a User Group is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any Systems it is connected to. It is arranged as a hash of System IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding System; this array reprents all grouping and/or associations that would have to be removed to deprovision that System from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_system_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_system" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_system`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/systems'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_group_traverse_system_group(self, group_id, **kwargs):
        """
        Get the System Groups a User Group is associatedwith.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any System Groups it is connected to. It is arranged as a hash of System Group IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding System Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that System Group from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_system_group(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_group_traverse_system_group_with_http_info(group_id, **kwargs)
        else:
            (data) = self.user_group_traverse_system_group_with_http_info(group_id, **kwargs)
            return data

    def user_group_traverse_system_group_with_http_info(self, group_id, **kwargs):
        """
        Get the System Groups a User Group is associatedwith.
        **read-only**  This endpoint follows the grouping and associations from this User Group to any System Groups it is connected to. It is arranged as a hash of System Group IDs for easy lookup.  It also contains a `path` array that describes each path from this User Group to the corresponding System Group; this array reprents all grouping and/or associations that would have to be removed to deprovision that System Group from this User Group. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_group_traverse_system_group_with_http_info(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id: ObjectID of the User Group. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_traverse_system_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `user_group_traverse_system_group`")


        collection_formats = {}

        resource_path = '/usergroups/{group_id}/systemgroups'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_member_of(self, user_id, **kwargs):
        """
        Get Users's groups it is a member of.
        This lists all groups a user is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_member_of(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_member_of_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_member_of_with_http_info(user_id, **kwargs)
            return data

    def user_member_of_with_http_info(self, user_id, **kwargs):
        """
        Get Users's groups it is a member of.
        This lists all groups a user is a member of. That is to say it includes nested group member of relationships as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_member_of_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_member_of" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_member_of`")


        collection_formats = {}

        resource_path = '/users/{user_id}/memberof'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_application(self, user_id, **kwargs):
        """
        Get the Applications a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Applications it is connected to.  It also contains a `path` array that describes each path from this User to the corresponding Application; this array reprents all grouping and/or associations that would have to be removed to deprovision that Application from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_application(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_application_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_application_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_application_with_http_info(self, user_id, **kwargs):
        """
        Get the Applications a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Applications it is connected to.  It also contains a `path` array that describes each path from this User to the corresponding Application; this array reprents all grouping and/or associations that would have to be removed to deprovision that Application from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_application_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_application`")


        collection_formats = {}

        resource_path = '/users/{user_id}/applications'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_directory(self, user_id, **kwargs):
        """
        Get the Directories a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Directory (G Suite, LDAP or Office 365) it is connected to. It is arranged as a hash of Directory IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding Directory; this array reprents all grouping and/or associations that would have to be removed to deprovision that Directory instance from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_directory(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_directory_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_directory_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_directory_with_http_info(self, user_id, **kwargs):
        """
        Get the Directories a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Directory (G Suite, LDAP or Office 365) it is connected to. It is arranged as a hash of Directory IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding Directory; this array reprents all grouping and/or associations that would have to be removed to deprovision that Directory instance from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_directory_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_directory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_directory`")


        collection_formats = {}

        resource_path = '/users/{user_id}/directories'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_g_suite(self, user_id, **kwargs):
        """
        Get the G Suite instance a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any G Suite instance it is connected to. It is arranged as a hash of G Suite instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding G Suite instance this array reprents all grouping and/or associations that would have to be removed to deprovision that G Suite instancefrom this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_g_suite(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_g_suite_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_g_suite_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_g_suite_with_http_info(self, user_id, **kwargs):
        """
        Get the G Suite instance a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any G Suite instance it is connected to. It is arranged as a hash of G Suite instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding G Suite instance this array reprents all grouping and/or associations that would have to be removed to deprovision that G Suite instancefrom this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_g_suite_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_g_suite" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_g_suite`")


        collection_formats = {}

        resource_path = '/users/{user_id}/gsuites'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_ldap_server(self, user_id, **kwargs):
        """
        Get the LDAP Servers a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any LDAP Servers it is connected to. It is arranged as a hash of LDAP Server IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding LDAP Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that LDAP Server from this User . See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_ldap_server(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_ldap_server_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_ldap_server_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_ldap_server_with_http_info(self, user_id, **kwargs):
        """
        Get the LDAP Servers a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any LDAP Servers it is connected to. It is arranged as a hash of LDAP Server IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding LDAP Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that LDAP Server from this User . See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_ldap_server_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_ldap_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_ldap_server`")


        collection_formats = {}

        resource_path = '/users/{user_id}/ldapservers'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_office365(self, user_id, **kwargs):
        """
        Get the Office 365 instance a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Office 365 instance it is connected to. It is arranged as a hash of Office 365 instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding Office 365 instance this array reprents all grouping and/or associations that would have to be removed to deprovision that Office 365 instancefrom this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_office365(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_office365_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_office365_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_office365_with_http_info(self, user_id, **kwargs):
        """
        Get the Office 365 instance a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Office 365 instance it is connected to. It is arranged as a hash of Office 365 instance IDs for easy lookup.  It also contains a `path` array that describes each path from this User to the corresponding Office 365 instance this array reprents all grouping and/or associations that would have to be removed to deprovision that Office 365 instancefrom this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_office365_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_office365" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_office365`")


        collection_formats = {}

        resource_path = '/users/{user_id}/office365s'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_radius_server(self, user_id, **kwargs):
        """
        Get the Radius Servers a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Radius Servers it is connected to.  It also contains a `path` array that describes each path from this User to the corresponding Radius Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that Radius Server from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_radius_server(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_radius_server_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_radius_server_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_radius_server_with_http_info(self, user_id, **kwargs):
        """
        Get the Radius Servers a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Radius Servers it is connected to.  It also contains a `path` array that describes each path from this User to the corresponding Radius Server; this array reprents all grouping and/or associations that would have to be removed to deprovision that Radius Server from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_radius_server_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_radius_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_radius_server`")


        collection_formats = {}

        resource_path = '/users/{user_id}/radiusservers'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_traverse_system(self, user_id, **kwargs):
        """
        Get the Systems a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Systems it is connected to.  It also contains a `path` array that describes each path from this User to the corresponding System; this array reprents all grouping and/or associations that would have to be removed to deprovision that System from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_system(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_traverse_system_with_http_info(user_id, **kwargs)
        else:
            (data) = self.user_traverse_system_with_http_info(user_id, **kwargs)
            return data

    def user_traverse_system_with_http_info(self, user_id, **kwargs):
        """
        Get the Systems a User is associated with.
        **read-only**  This endpoint follows the grouping and associations from this User to any Systems it is connected to.  It also contains a `path` array that describes each path from this User to the corresponding System; this array reprents all grouping and/or associations that would have to be removed to deprovision that System from this User. See `/members` and `/associations` endpoints to manage those collections. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_traverse_system_with_http_info(user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str user_id: ObjectID of the User. (required)
        :param int limit: The number of records to return at once.
        :param int skip: The offset into the records to return.
        :param str sort: The comma separated fields used to sort the collection. Default sort is ascending, prefix with `-` to sort descending. 
        :param str fields: The comma separated fields included in the returned records. If omitted the default list of fields will be returned. 
        :param str filter: 
        :return: list[GraphObjectWithPaths]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'limit', 'skip', 'sort', 'fields', 'filter']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_traverse_system" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_traverse_system`")


        collection_formats = {}

        resource_path = '/users/{user_id}/systems'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'skip' in params:
            query_params['skip'] = params['skip']
        if 'sort' in params:
            query_params['sort'] = params['sort']
        if 'fields' in params:
            query_params['fields'] = params['fields']
        if 'filter' in params:
            query_params['filter'] = params['filter']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json; charset=utf-8'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GraphObjectWithPaths]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
